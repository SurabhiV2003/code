					
						Exception handling
==============================================================================================================================	

1.
public class Test {
    public static void main(String[] args) {
        try {
            int a = 5 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Arithmetic");
        } catch (Exception e) {
            System.out.println("General");
        }
    }
}

Options:
A. Arithmetic
B. General
C. Compile-time error
D. Runtime error

Answer: A. Arithmetic

Explanation:
Division by zero → ArithmeticException.
First catch matches → prints "Arithmetic".



2.
public class Test {
    public static void main(String[] args) {
        try {
            String s = null;
            System.out.println(s.length());
        } catch (RuntimeException e) {
            System.out.println("Runtime");
        } catch (NullPointerException e) {
            System.out.println("Null");
        }
    }
}

Options:
A. Runtime
B. Null
C. Compile-time error
D. No output

Answer: C. Compile-time error

Explanation:
NullPointerException is a subclass of RuntimeException.
Subclass cannot follow superclass in catch → compiler error.



Q3.
public class Test {
    public static void main(String[] args) {
        try {
            throw new Exception("Test");
        } catch (ArithmeticException e) {
            System.out.println("Arithmetic");
        }
    }
}


Options:
A. Test
B. Arithmetic
C. Compile-time error
D. Runtime Exception

Answer: C. Compile-time error

Explanation:
Exception is checked → must be caught or declared.



4.
public class Test {
    public static void main(String[] args) {
        try {
            int arr[] = new int[3];
            arr[5] = 10;
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array Error");
        } finally {
            System.out.println("Finally Block");
        }
    }
}

Options:
A. Array Error
B. Finally Block
C. Array Error + Finally Block
D. No output

Answer: C. Array Error + Finally Block

Explanation:
Exception handled → prints "Array Error".
Finally always executes → "Finally Block".



5.
public class Test {
    public static void main(String[] args) {
        try {
            System.out.println("Try");
            return;
        } finally {
            System.out.println("Finally");
        }
    }
}

Options:
A. Try
B. Finally
C. Try + Finally
D. Only Try

Answer: C. Try + Finally

Explanation:
Finally executes even after return in try.



Q6.
public class Test {
    static void method() throws Exception {
        throw new Exception("Checked");
    }
    public static void main(String[] args) {
        try {
            method();
        } catch (RuntimeException e) {
            System.out.println("Runtime");
        }
    }
}

Options:
A. Checked
B. Runtime
C. Compile-time error
D. No output

Answer: C. Compile-time error

Explanation:
Checked exception not handled properly → compile-time error.



7.
public class Test {
    public static void main(String[] args) {
        try {
            int x = Integer.parseInt("abc");
        } catch (NumberFormatException e) {
            System.out.println("Number Format");
        }
    }
}

Options:
A. abc
B. Number Format
C. Compile-time error
D. Runtime crash

Answer: B. Number Format

Explanation:
"abc" cannot be parsed → NumberFormatException.



8.
public class Test {
    public static void main(String[] args) {
        try {
            Object obj = "Hello";
            Integer i = (Integer) obj;
        } catch (ClassCastException e) {
            System.out.println("ClassCast");
        }
    }
}

Options:
A. Hello
B. ClassCast
C. Compile-time error
D. No output

Answer: B. ClassCast

Explanation:
String cannot cast to Integer → ClassCastException.



9.
public class Test {
    public static void main(String[] args) {
        try {
            String s = "10";
            int x = Integer.valueOf(s);
            System.out.println(x);
        } catch (Exception e) {
            System.out.println("Error");
        }
    }
}

Options:
A. 10
B. Error
C. Compile-time error
D. Runtime error

Answer: A. 10

Explanation:
"10" is a valid integer string.



10.
public class Test {
    public static void main(String[] args) {
        try {
            System.out.println("A");
            throw new RuntimeException("B");
        } catch (Exception e) {
            System.out.println("C");
        } finally {
            System.out.println("D");
        }
    }
}

Options:
A. A B
B. A C D
C. A D
D. A Runtime error

Answer: B. A C D

Explanation:
"A" prints. Exception caught → "C". Finally → "D".



11.
public class Test {
    try {
        throw new Error("Severe");
    } catch (Exception e) {
        System.out.println("Exception");
    } finally {
        System.out.println("Finally");
    }
}

Options:
A. Exception
B. Finally
C. Exception + Finally
D. Finally + Runtime crash

Answer: D. Finally + Runtime crash

Explanation:
Error not caught. Finally executes → then JVM crashes.



12.
public class Test {
    public static void main(String[] args) {
        try {
            System.exit(0);
        } finally {
            System.out.println("Finally");
        }
    }
}

Options:
A. Finally
B. No output
C. Runtime error
D. Compile-time error

Answer: B. No output

Explanation:
JVM terminates → finally skipped.



13.
public class Test {
    public static void main(String[] args) {
        try {
            throw new NullPointerException();
        } catch (NullPointerException | ArithmeticException e) {
            System.out.println("Multi-catch");
        }
    }
}

Options:
A. NullPointerException
B. ArithmeticException
C. Multi-catch
D. Compile-time error

Answer: C. Multi-catch

Explanation:
NullPointerException caught in multi-catch → prints "Multi-catch".



14.
class MyException extends Exception {
    MyException(String msg) { super(msg); }
}
public class Test {
    public static void main(String[] args) {
        try {
            throw new MyException("Custom");
        } catch (MyException e) {
            System.out.println(e.getMessage());
        }
    }
}

Options:
A. MyException
B. Custom
C. Runtime error
D. Compile-time error

Answer: B. Custom

Explanation:
User-defined exception message "Custom" returned by getMessage().



15.
public class Test {
    static int method() {
        try {
            return 10;
        } finally {
            return 20;
        }
    }
    public static void main(String[] args) {
        System.out.println(method());
    }
}

Options:
A. 10
B. 20
C. Compile-time error
D. Unpredictable

Answer: B. 20

Explanation:
Return in finally overrides try → returns 20.


					
							String handling
==============================================================================================================================

1.
String s1 = "Java";
String s2 = "Java";
System.out.println(s1 == s2);

Options:
A. true
B. false
C. Compile-time error
D. Runtime exception

Answer: A. true

Explanation:
Both s1 and s2 point to the same string literal in the string pool → == returns true.



2.
String s1 = new String("Java");
String s2 = new String("Java");
System.out.println(s1 == s2);
System.out.println(s1.equals(s2));

Options:
A. true, true
B. false, true
C. true, false
D. false, false

Answer: B. false, true

Explanation:
== compares references → different objects → false.
equals() compares content → true.



3.
String s = "hello";
s.concat(" world");
System.out.println(s);

Options:
A. hello world
B. hello
C. Compile-time error
D. Runtime exception

Answer: B. hello

Explanation:
Strings are immutable. concat() creates a new string but original s is unchanged.



4.
String s = "Java";
s = s.concat(" Programming");
System.out.println(s);

Options:
A. Java
B. Java Programming
C. Compile-time error
D. Runtime exception

Answer: B. Java Programming

Explanation:

Assigning the result of concat() to s updates the reference.



5.
String s = "Java";
System.out.println(s.charAt(2));

Options:
A. a
B. v
C. J
D. Compile-time error

Answer: B. v

Explanation:
Indexing starts at 0 → s.charAt(2) → 'v'.



6.
String s = "Java";
System.out.println(s.substring(1, 3));

Options:
A. Ja
B. av
C. Jav
D. Compile-time error

Answer: B. av

Explanation:
substring(start, end) → start inclusive, end exclusive → index 1,2 → "av".



7.
String s = "Java";
System.out.println(s.indexOf("a", 2));

Options:
A. 1
B. 3
C. 2
D. -1

Answer: B. 3
Explanation:
indexOf("a",2) → searches from index 2 → next 'a' at index 3.



8.
String s = "Java Programming";
System.out.println(s.replace("a", "o"));

Options:
A. Jovo Progromming
B. Jovo Programming
C. Java Programming
D. Compile-time error

Answer: A. Jovo Progromming
Explanation:
replace(char old, char new) replaces all occurrences of 'a' with 'o'.



9.
String s = "Java";
System.out.println(s.toUpperCase().toLowerCase());

Options:
A. JAVA
B. java
C. Java
D. Compile-time error

Answer: B. java

Explanation:
toUpperCase() → "JAVA" → toLowerCase() → "java".


10.
String s = "  Java  ";
System.out.println(s.trim());

Options:
A. Java
B. Java
C. Java
D. " Java "

Answer: A. Java

Explanation:
trim() removes leading and trailing spaces.



11.
String s1 = "Java";
String s2 = "java";
System.out.println(s1.equalsIgnoreCase(s2));

Options:
A. true
B. false
C. Compile-time error
D. Runtime error

Answer: A. true

Explanation:
equalsIgnoreCase() compares content ignoring case.



12.
String s = "Java,Python,Cpp";
String arr[] = s.split(",");
System.out.println(arr[1]);

Options:
A. Java
B. Python
C. Cpp
D. Compile-time error

Answer: B. Python

Explanation:
split(",") → array ["Java","Python","Cpp"] → index 1 → "Python".



13.
String s1 = "Java";
String s2 = s1.intern();
System.out.println(s1 == s2);

Options:
A. true
B. false
C. Compile-time error
D. Runtime error

Answer: A. true

Explanation:
intern() returns reference from string pool.



Q14.
String s = "Java";
System.out.println(s.startsWith("Ja"));

Options:
A. true
B. false
C. Compile-time error
D. Runtime error

Answer: A. true

Explanation:
startsWith() checks beginning of string → "Ja" matches.



Q15.
String s = "Programming";
System.out.println(s.substring(s.length() - 3));

Options:
A. ing
B. mming
C. Programming
D. Runtime error

Answer: A. ing

Explanation:
substring(s.length()-3) → last 3 characters → "ing".